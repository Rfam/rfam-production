import os
import sys
import json
import copy

import genome_download_validator as gdv

# -----------------------------------------------------------------------------------------------------------


def check_seq_file(upid, seq_file, err_file_fp=None):

    # check if fasta file exists
    acc = os.path.basename(seq_file).partition('.')[0]
    if os.path.exists(seq_file):
        # we may want to delete the incorrect files to clean up the sequence directory
        if not gdv.check_file_format(seq_file):
            print "%s\t%s\tIncorrect file format or empty file" % (upid, acc)
            if err_file_fp is not None:
                err_file_fp.write("%s\t%s\tIncorrect file format or empty file\n" % (upid, acc))
            return False

    else:
        if err_file_fp is not None:
            err_file_fp.write("%s\t%s\tMissing file\n" % (upid, acc))
        print "%s\t%s\tMissing file" % (upid, acc)
        return False

    return True

# ---------------------------------------------------------------------------------------------------------


def validate_genome_download(project_dir):
    """
    This function will loop over all directories in a genome download project and run a couple of
    validation steps to evaluate the state of the download and report any issues identified

    project_dir: A valid path to a genome download project directory as generated by the
    genome_downloader pipeline

    return:
    """

    upid_gca_file = os.path.join(project_dir, "upid_gca_dict.json")

    # load genome accessions
    fp = open(upid_gca_file)
    upid_gca_dict = json.load(fp)
    fp.close()

    upids = upid_gca_dict.keys()

    # validate all genomes in project directory
    for upid in upids:
        # 1. get updir loc
        upid_idx = upid[-3:]
        subdir_loc = os.path.join(project_dir, upid_idx)
        updir_loc = os.path.join(subdir_loc, upid)

        if not os.path.exists(updir_loc):
            print "%s\tOutput directory is missing" % upid

        else:
            # create genome specific err file
            upid_err_fp = open(os.path.join(updir_loc, upid + '.err'), 'w')
            # look for gca report file and count downloaded files
            # check download status was successful
            if gdv.check_genome_download_status(os.path.join(updir_loc, "download.out")):

                seq_dir_loc = os.path.join(updir_loc, "sequences")
                uniprot_acc_file = os.path.join(updir_loc, upid + '_accessions.json')

                proteome_accs = {}

                if not os.path.exists(uniprot_acc_file):
                    print "%s\tMissing proteome_accessions file" % upid
                    upid_err_fp.write("%s\tMissing proteome_accessions file\n" % upid)

                    fp = open(uniprot_acc_file, 'r')
                    proteome_accs = json.load(fp)
                    fp.close()

                if upid_gca_dict[upid]["GCA"] != -1:
                    gca_report_file = os.path.join(updir_loc,
                                                   upid_gca_dict[upid]["GCA"] + "_sequence_report.txt")

                    # 2. Check if gca file and load accessions
                    if os.path.exists(gca_report_file):
                        # get unique accessions
                        fp = open(gca_report_file, 'r')
                        accs = [x.strip().split('\t')[0].partition('.')[0] for x in fp]
                        fp.close()

                        complete_accs = []
                        accs.pop(0)  # remove header

                        if proteome_accs != {}:
                            cleaned_gca_accs = set(accs)
                            upid_other_accs = set(proteome_accs["OTHER"].values())
                            complete_accs = upid_other_accs.union(cleaned_gca_accs)

                        else:
                            complete_accs = copy.deepcopy(accs)

                        seq_items = os.listdir(seq_dir_loc)  # dir or file
                        # check if multiple directories, else erroneous download
                        if len(seq_items) == 0:
                            print "%s\tEmpty sequence directory" % upid
                            upid_err_fp.write("%s\tEmpty sequence directory\n" % upid)

                        else:
                            # A - sequence directory only contains fasta files
                            if os.path.isfile(os.path.join(seq_dir_loc, seq_items[0])):
                                for acc in complete_accs:
                                    seq_file = os.path.join(seq_dir_loc, acc + ".fa")
                                    # check if fasta file exists
                                    check_seq_file(upid, seq_file, upid_err_fp)

                            # B - multiple subdirectories
                            else:
                                copy_of_accessions = copy.deepcopy(complete_accs)
                                # to speed up the process we will work with subdirs instead
                                # and remove the acc from the list if everything is ok with the file
                                for subdir in seq_items:
                                    subdir_loc = os.path.join(seq_dir_loc, subdir)
                                    seq_files = os.listdir(subdir_loc)

                                    for seq_file in seq_files:
                                        sec_file_loc = os.path.join(subdir_loc, seq_file)

                                        if check_seq_file(upid, seq_file, upid_err_fp):
                                            acc = seq_file.partition('.')[0]
                                            # delete accession from list to be used for qc later
                                            copy_of_accessions.remove(acc)

                                if len(copy_of_accessions) > 0:
                                    for acc in copy_of_accessions:
                                        print "%s\t%s\tMissing file" % (upid, acc)
                                        upid_err_fp.write("%s\t%s\tMissing file\n" % (upid, acc))

                # check WGS set has been copied
                else:
                    if proteome_accs != {}:
                        wgs_prefix = proteome_accs["WGS"][0:6]
                        wgs_file_loc = os.path.join(seq_dir_loc,
                                                    wgs_prefix + ".fasta.gz")

                        if not os.path.exists(wgs_file_loc):
                            print "%s\t%s\tWGS file has not been copied" % (upid,
                                                                            wgs_prefix + ".fasta.gz")
                            upid_err_fp.write("%s\t%s\tWGS file has not been copied\n" % (upid,
                                                                                          wgs_prefix + ".fasta.gz"))
                    else:
                        wgs_file = [x for x in os.listdir(seq_dir_loc) if x.endswith(".fasta.gz")]

                        if len(wgs_file) == 0:
                            print "%s\tWGS file has not been copied" % (upid)
                            upid_err_fp.write("%s\tWGS file has not been copied\n" % upid)
            else:
                print "%s\tUnsuccessful download" % upid

# -----------------------------------------------------------------------------------------------------------

if __name__ == '__main__':

    """
    Usage python validate_genomes.py /path/to/project/dir > genome_validation_report.txt
    """
    project_dir = sys.argv[1]
    validate_genome_download(project_dir)

